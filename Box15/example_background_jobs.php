<?php

require_once __DIR__ . '/CallbackRegistry.php';

/**
 * Background Job Dispatcher
 * 
 * Simulates a background job dispatcher that serializes job data
 * and sends it to a worker process.
 */
class BackgroundJobDispatcher
{
    public function dispatch(array $jobData): void
    {
        // In real implementation, this would:
        // 1. Serialize the job data
        // 2. Send to queue (Redis, RabbitMQ, etc.)
        // 3. Worker picks it up in separate process
        
        $serialized = serialize($jobData);
        echo "✓ Job dispatched: " . json_encode($jobData, JSON_PRETTY_PRINT) . "\n";
        echo "✓ Serialized size: " . strlen($serialized) . " bytes\n\n";
        
        // Simulate worker execution
        $this->simulateWorkerExecution($jobData);
    }
    
    private function simulateWorkerExecution(array $jobData): void
    {
        echo "--- Worker Process Started ---\n";
        
        // Worker must have its own registry initialized
        $workerRegistry = $this->initializeWorkerRegistry();
        
        $executor = new BackgroundJobExecutor($workerRegistry);
        $executor->execute($jobData);
        
        echo "--- Worker Process Completed ---\n\n";
    }
    
    private function initializeWorkerRegistry(): CallbackRegistry
    {
        // In real implementation, worker would call the same
        // initialization function as the main process
        return initializeCallbackRegistry();
    }
}

/**
 * Background Job Executor
 * 
 * Executes jobs in the worker process using the callback registry
 */
class BackgroundJobExecutor
{
    private CallbackRegistry $registry;
    
    public function __construct(CallbackRegistry $registry)
    {
        $this->registry = $registry;
    }
    
    public function execute(array $jobData): void
    {
        $callbackName = $jobData['callback_name'];
        $params = $jobData['params'] ?? [];
        
        echo "Executing job with callback: {$callbackName}\n";
        
        // Get callback from registry
        $callback = $this->registry->get($callbackName);
        
        if ($callback === null) {
            throw new Exception("Callback not found: {$callbackName}");
        }
        
        // Execute callback
        $result = $callback($params);
        
        // In real implementation, would cache the result
        echo "✓ Generated content (" . strlen($result) . " bytes)\n";
        echo "✓ Content preview: " . substr($result, 0, 100) . "...\n";
    }
}

/**
 * Initialize the callback registry
 * This function must be called in both main and worker processes
 */
function initializeCallbackRegistry(): CallbackRegistry
{
    $registry = new CallbackRegistry();
    
    // Homepage callback
    $registry->register('homepage', function() {
        return "<html>
    <head><title>Homepage</title></head>
    <body>
        <h1>Welcome to Our Website</h1>
        <p>This content was generated by a background job!</p>
    </body>
</html>";
    }, [
        'description' => 'Main homepage',
        'default_ttl' => 3600,
        'priority' => 'high'
    ]);
    
    // Blog post callback (parameterized)
    $registry->register('blog_post', function($params) {
        $postId = $params['post_id'];
        $title = $params['title'] ?? 'Untitled';
        
        return "<html>
    <head><title>{$title}</title></head>
    <body>
        <article>
            <h1>{$title}</h1>
            <p>This is blog post #{$postId}</p>
            <p>Content generated dynamically...</p>
        </article>
    </body>
</html>";
    }, [
        'description' => 'Individual blog post',
        'default_ttl' => 7200
    ]);
    
    // API response callback
    $registry->register('api_response', function($params) {
        $endpoint = $params['endpoint'];
        
        return json_encode([
            'status' => 'success',
            'endpoint' => $endpoint,
            'data' => ['item1', 'item2', 'item3'],
            'timestamp' => time()
        ]);
    }, [
        'description' => 'API response generator',
        'default_ttl' => 300
    ]);
    
    return $registry;
}

// ============================================================================
// DEMO: Background Job Integration
// ============================================================================

echo "=== Background Job Integration Demo ===\n\n";

// Initialize registry in main process
$registry = initializeCallbackRegistry();

echo "Registered callbacks: " . implode(', ', $registry->list()) . "\n\n";

// Create dispatcher
$dispatcher = new BackgroundJobDispatcher();

// Example 1: Homepage generation
echo "Example 1: Regenerate Homepage\n";
echo "--------------------------------\n";
$dispatcher->dispatch([
    'task' => 'regenerate_cache',
    'callback_name' => 'homepage',
    'url' => '/'
]);

// Example 2: Blog post with parameters
echo "Example 2: Regenerate Blog Post\n";
echo "--------------------------------\n";
$dispatcher->dispatch([
    'task' => 'regenerate_cache',
    'callback_name' => 'blog_post',
    'params' => [
        'post_id' => 42,
        'title' => 'Understanding CallbackRegistry'
    ],
    'url' => '/blog/understanding-callback-registry'
]);

// Example 3: API response
echo "Example 3: Regenerate API Response\n";
echo "--------------------------------\n";
$dispatcher->dispatch([
    'task' => 'regenerate_cache',
    'callback_name' => 'api_response',
    'params' => [
        'endpoint' => '/api/v1/products'
    ],
    'url' => '/api/v1/products'
]);

// Example 4: Demonstrate the serialization problem (WRONG WAY)
echo "Example 4: Why Closures Don't Work (WRONG WAY)\n";
echo "------------------------------------------------\n";
try {
    $wrongJob = [
        'task' => 'regenerate_cache',
        'callback' => function() { return "This won't work!"; }
    ];
    
    $serialized = serialize($wrongJob);
    echo "✗ This would fail in a real queue!\n";
} catch (Exception $e) {
    echo "✗ Error: " . $e->getMessage() . "\n";
}
echo "\n";

// Example 5: Inspect registry
echo "Example 5: Registry Inspection\n";
echo "--------------------------------\n";
foreach ($registry->getAllInfo() as $name => $info) {
    echo "Callback: {$name}\n";
    echo "  Description: " . ($info['metadata']['description'] ?? 'N/A') . "\n";
    echo "  TTL: " . ($info['metadata']['default_ttl'] ?? 'N/A') . " seconds\n";
    echo "  Registered: " . date('Y-m-d H:i:s', $info['registered_at']) . "\n";
    echo "\n";
}
